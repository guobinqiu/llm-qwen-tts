{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nexport default {\n  data() {\n    return {\n      text: '',\n      message: '',\n      messages: [],\n      sessionID: 'sess1',\n      wsText: null,\n      wsAudio: null,\n      audioCtx: null,\n      audioPlayingNodes: [],\n      userInteracted: false,\n      // 用于第一次交互激活 AudioContext\n      audioChunks: [],\n      // 存储原始Float32Array数据\n      audioSampleRate: 24000,\n      playbackSource: null,\n      isPlaying: false\n    };\n  },\n  computed: {\n    showMessages() {\n      const all = [...this.messages];\n      if (this.message.trim()) {\n        all.push({\n          role: 'assistant',\n          content: this.message\n        });\n      }\n      return all;\n    }\n  },\n  methods: {\n    sendText() {\n      if (!this.text.trim()) return;\n      if (!this.userInteracted) {\n        this.resumeAudioContext();\n        this.userInteracted = true;\n      }\n      this.wsText.send(this.text.trim());\n      this.messages.push({\n        role: 'user',\n        content: this.text.trim()\n      });\n      this.text = '';\n    },\n    resumeAudioContext() {\n      if (this.audioCtx && this.audioCtx.state === 'suspended') {\n        this.audioCtx.resume();\n      }\n    },\n    setupTextSocket() {\n      this.wsText = new WebSocket(`ws://localhost:8080/ws/text-stream?sessionid=${this.sessionID}`);\n      this.wsText.onopen = () => {\n        console.log('文本 WebSocket 已连接');\n      };\n      this.wsText.onmessage = event => {\n        const chunk = event.data;\n        this.message += chunk;\n        if (chunk === '\\n\\n') {\n          this.messages.push({\n            role: 'assistant',\n            content: this.message\n          });\n          this.message = '';\n        }\n      };\n      this.wsText.onerror = e => {\n        console.error('文本 WebSocket 错误', e);\n      };\n      this.wsText.onclose = () => {\n        console.log('文本 WebSocket 已关闭');\n      };\n    },\n    // 修改 setupAudioSocket 方法\n    setupAudioSocket() {\n      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      this.audioQueue = [];\n      this.currentlyPlaying = false;\n      this.wsAudio = new WebSocket(`ws://localhost:8080/ws/audio-stream?sessionid=${this.sessionID}`);\n      this.wsAudio.binaryType = 'arraybuffer';\n      this.wsAudio.onopen = () => {\n        console.log('音频 WebSocket 已连接');\n      };\n      this.wsAudio.onmessage = event => {\n        if (!this.userInteracted) {\n          this.resumeAudioContext();\n          this.userInteracted = true;\n        }\n        try {\n          const arrayBuffer = event.data;\n          console.log('接收到音频数据，字节长度:', arrayBuffer.byteLength);\n\n          // 转换为AudioBuffer\n          const pcmData = new Int16Array(arrayBuffer);\n          const float32Data = new Float32Array(pcmData.length);\n          for (let i = 0; i < pcmData.length; i++) {\n            float32Data[i] = pcmData[i] / 32768.0;\n          }\n          const audioBuffer = this.audioCtx.createBuffer(1, float32Data.length, this.audioSampleRate);\n          audioBuffer.getChannelData(0).set(float32Data);\n\n          // 添加到队列\n          this.audioQueue.push(audioBuffer);\n          console.log(`音频块加入队列，队列长度: ${this.audioQueue.length}, 块时长: ${audioBuffer.duration.toFixed(3)}秒`);\n\n          // 尝试开始播放\n          this.tryPlayNext();\n        } catch (err) {\n          console.error('处理音频数据失败:', err);\n        }\n      };\n      this.wsAudio.onerror = e => {\n        console.error('音频 WebSocket 错误', e);\n      };\n      this.wsAudio.onclose = () => {\n        console.log('音频 WebSocket 已关闭');\n        this.stopAllAudio();\n      };\n    },\n    // 新的播放逻辑\n    tryPlayNext() {\n      // 如果正在播放或队列为空，不处理\n      if (this.currentlyPlaying || this.audioQueue.length === 0) {\n        console.log(`播放状态: ${this.currentlyPlaying}, 队列长度: ${this.audioQueue.length}`);\n        return;\n      }\n      console.log('开始播放下一个音频块');\n      this.currentlyPlaying = true;\n      const audioBuffer = this.audioQueue.shift();\n      const source = this.audioCtx.createBufferSource();\n      source.buffer = audioBuffer;\n      source.connect(this.audioCtx.destination);\n      source.onended = () => {\n        console.log('音频块播放完毕');\n        // 从播放列表中移除\n        const idx = this.audioPlayingNodes.indexOf(source);\n        if (idx !== -1) {\n          this.audioPlayingNodes.splice(idx, 1);\n        }\n\n        // 标记当前不在播放状态\n        this.currentlyPlaying = false;\n\n        // 立即尝试播放下一个\n        setTimeout(() => {\n          this.tryPlayNext();\n        }, 10); // 很短的延迟，避免阻塞\n      };\n      this.audioPlayingNodes.push(source);\n      source.start();\n      console.log(`开始播放音频块，时长: ${audioBuffer.duration.toFixed(3)}秒`);\n    },\n    // 新增方法：连续播放音频队列\n    playAudioQueue() {\n      if (this.audioQueue.length === 0) {\n        this.isPlayingAudio = false;\n        return;\n      }\n      this.isPlayingAudio = true;\n      const audioBuffer = this.audioQueue.shift();\n      const source = this.audioCtx.createBufferSource();\n      source.buffer = audioBuffer;\n      source.connect(this.audioCtx.destination);\n\n      // 计算播放时间，确保连续播放\n      const currentTime = this.audioCtx.currentTime;\n      const startTime = Math.max(currentTime, this.nextPlayTime);\n      source.onended = () => {\n        // 从播放列表中移除\n        const idx = this.audioPlayingNodes.indexOf(source);\n        if (idx !== -1) this.audioPlayingNodes.splice(idx, 1);\n\n        // 继续播放队列中的下一个音频块\n        setTimeout(() => this.playAudioQueue(), 10); // 小延迟防止卡顿\n      };\n      this.audioPlayingNodes.push(source);\n      source.start(startTime);\n\n      // 更新下次播放时间\n      this.nextPlayTime = startTime + audioBuffer.duration;\n      console.log(`播放音频块，时长: ${audioBuffer.duration.toFixed(3)}秒，开始时间: ${startTime.toFixed(3)}秒`);\n    },\n    // 修改 stopAllAudio 方法\n    stopAllAudio() {\n      console.log('停止所有音频播放');\n\n      // 停止所有正在播放的音频\n      this.audioPlayingNodes.forEach(node => {\n        try {\n          node.stop();\n        } catch (e) {\n          console.error('停止音频节点失败:', e);\n        }\n      });\n      this.audioPlayingNodes = [];\n\n      // 重置状态\n      this.audioQueue = [];\n      this.currentlyPlaying = false;\n      console.log('所有音频已停止，状态已重置');\n    }\n  },\n  mounted() {\n    // 监听用户交互，保证 AudioContext 激活\n    window.addEventListener('click', () => {\n      if (!this.userInteracted) {\n        this.resumeAudioContext();\n        this.userInteracted = true;\n      }\n    }, {\n      once: true\n    });\n    this.setupTextSocket();\n    this.setupAudioSocket();\n  },\n  beforeDestroy() {\n    if (this.wsText) this.wsText.close();\n    if (this.wsAudio) this.wsAudio.close();\n    this.stopAllAudio();\n    if (this.audioCtx) this.audioCtx.close();\n  }\n};","map":{"version":3,"names":["data","text","message","messages","sessionID","wsText","wsAudio","audioCtx","audioPlayingNodes","userInteracted","audioChunks","audioSampleRate","playbackSource","isPlaying","computed","showMessages","all","trim","push","role","content","methods","sendText","resumeAudioContext","send","state","resume","setupTextSocket","WebSocket","onopen","console","log","onmessage","event","chunk","onerror","e","error","onclose","setupAudioSocket","window","AudioContext","webkitAudioContext","audioQueue","currentlyPlaying","binaryType","arrayBuffer","byteLength","pcmData","Int16Array","float32Data","Float32Array","length","i","audioBuffer","createBuffer","getChannelData","set","duration","toFixed","tryPlayNext","err","stopAllAudio","shift","source","createBufferSource","buffer","connect","destination","onended","idx","indexOf","splice","setTimeout","start","playAudioQueue","isPlayingAudio","currentTime","startTime","Math","max","nextPlayTime","forEach","node","stop","mounted","addEventListener","once","beforeDestroy","close"],"sources":["src/components/ChatPage.vue"],"sourcesContent":["<template>\n  <div>\n    <div>\n      <input\n        v-model=\"text\"\n        placeholder=\"输入文本，回车发送\"\n        @keyup.enter=\"sendText\"\n        style=\"width: 300px; padding: 8px\"\n      />\n      <button @click=\"sendText\">发送</button>\n    </div>\n\n    <div style=\"margin-top: 20px;\">\n      <div v-for=\"(msg, index) in showMessages\" :key=\"index\">\n        <b>{{ msg.role }}:</b> {{ msg.content }}\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      text: '',\n      message: '',\n      messages: [],\n      sessionID: 'sess1',\n      wsText: null,\n      wsAudio: null,\n      audioCtx: null,\n      audioPlayingNodes: [],\n      userInteracted: false, // 用于第一次交互激活 AudioContext\n      audioChunks: [], // 存储原始Float32Array数据\n    audioSampleRate: 24000,\n    playbackSource: null,\n    isPlaying: false,\n    };\n  },\n  computed: {\n    showMessages() {\n      const all = [...this.messages];\n      if (this.message.trim()) {\n        all.push({ role: 'assistant', content: this.message });\n      }\n      return all;\n    }\n  },\n  methods: {\n    sendText() {\n      if (!this.text.trim()) return;\n\n      if (!this.userInteracted) {\n        this.resumeAudioContext();\n        this.userInteracted = true;\n      }\n\n      this.wsText.send(this.text.trim());\n      this.messages.push({ role: 'user', content: this.text.trim() });\n      this.text = '';\n    },\n    resumeAudioContext() {\n      if (this.audioCtx && this.audioCtx.state === 'suspended') {\n        this.audioCtx.resume();\n      }\n    },\n    setupTextSocket() {\n      this.wsText = new WebSocket(`ws://localhost:8080/ws/text-stream?sessionid=${this.sessionID}`);\n\n      this.wsText.onopen = () => {\n        console.log('文本 WebSocket 已连接');\n      };\n\n      this.wsText.onmessage = (event) => {\n        const chunk = event.data;\n        this.message += chunk;\n\n        if (chunk === '\\n\\n') {\n          this.messages.push({ role: 'assistant', content: this.message });\n          this.message = '';\n        }\n      };\n\n      this.wsText.onerror = (e) => {\n        console.error('文本 WebSocket 错误', e);\n      };\n\n      this.wsText.onclose = () => {\n        console.log('文本 WebSocket 已关闭');\n      };\n    },\n   // 修改 setupAudioSocket 方法\nsetupAudioSocket() {\n  this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n  this.audioQueue = [];\n  this.currentlyPlaying = false;\n\n  this.wsAudio = new WebSocket(`ws://localhost:8080/ws/audio-stream?sessionid=${this.sessionID}`);\n  this.wsAudio.binaryType = 'arraybuffer';\n\n  this.wsAudio.onopen = () => {\n    console.log('音频 WebSocket 已连接');\n  };\n\n  this.wsAudio.onmessage = (event) => {\n    if (!this.userInteracted) {\n      this.resumeAudioContext();\n      this.userInteracted = true;\n    }\n\n    try {\n      const arrayBuffer = event.data;\n      console.log('接收到音频数据，字节长度:', arrayBuffer.byteLength);\n      \n      // 转换为AudioBuffer\n      const pcmData = new Int16Array(arrayBuffer);\n      const float32Data = new Float32Array(pcmData.length);\n      \n      for (let i = 0; i < pcmData.length; i++) {\n        float32Data[i] = pcmData[i] / 32768.0;\n      }\n      \n      const audioBuffer = this.audioCtx.createBuffer(1, float32Data.length, this.audioSampleRate);\n      audioBuffer.getChannelData(0).set(float32Data);\n      \n      // 添加到队列\n      this.audioQueue.push(audioBuffer);\n      console.log(`音频块加入队列，队列长度: ${this.audioQueue.length}, 块时长: ${audioBuffer.duration.toFixed(3)}秒`);\n      \n      // 尝试开始播放\n      this.tryPlayNext();\n      \n    } catch (err) {\n      console.error('处理音频数据失败:', err);\n    }\n  };\n\n  this.wsAudio.onerror = (e) => {\n    console.error('音频 WebSocket 错误', e);\n  };\n\n  this.wsAudio.onclose = () => {\n    console.log('音频 WebSocket 已关闭');\n    this.stopAllAudio();\n  };\n},\n\n// 新的播放逻辑\ntryPlayNext() {\n  // 如果正在播放或队列为空，不处理\n  if (this.currentlyPlaying || this.audioQueue.length === 0) {\n    console.log(`播放状态: ${this.currentlyPlaying}, 队列长度: ${this.audioQueue.length}`);\n    return;\n  }\n  \n  console.log('开始播放下一个音频块');\n  this.currentlyPlaying = true;\n  \n  const audioBuffer = this.audioQueue.shift();\n  const source = this.audioCtx.createBufferSource();\n  source.buffer = audioBuffer;\n  source.connect(this.audioCtx.destination);\n  \n  source.onended = () => {\n    console.log('音频块播放完毕');\n    // 从播放列表中移除\n    const idx = this.audioPlayingNodes.indexOf(source);\n    if (idx !== -1) {\n      this.audioPlayingNodes.splice(idx, 1);\n    }\n    \n    // 标记当前不在播放状态\n    this.currentlyPlaying = false;\n    \n    // 立即尝试播放下一个\n    setTimeout(() => {\n      this.tryPlayNext();\n    }, 10); // 很短的延迟，避免阻塞\n  };\n  \n  this.audioPlayingNodes.push(source);\n  source.start();\n  \n  console.log(`开始播放音频块，时长: ${audioBuffer.duration.toFixed(3)}秒`);\n},\n\n    // 新增方法：连续播放音频队列\n    playAudioQueue() {\n      if (this.audioQueue.length === 0) {\n        this.isPlayingAudio = false;\n        return;\n      }\n      \n      this.isPlayingAudio = true;\n      const audioBuffer = this.audioQueue.shift();\n      \n      const source = this.audioCtx.createBufferSource();\n      source.buffer = audioBuffer;\n      source.connect(this.audioCtx.destination);\n      \n      // 计算播放时间，确保连续播放\n      const currentTime = this.audioCtx.currentTime;\n      const startTime = Math.max(currentTime, this.nextPlayTime);\n      \n      source.onended = () => {\n        // 从播放列表中移除\n        const idx = this.audioPlayingNodes.indexOf(source);\n        if (idx !== -1) this.audioPlayingNodes.splice(idx, 1);\n        \n        // 继续播放队列中的下一个音频块\n        setTimeout(() => this.playAudioQueue(), 10); // 小延迟防止卡顿\n      };\n      \n      this.audioPlayingNodes.push(source);\n      source.start(startTime);\n      \n      // 更新下次播放时间\n      this.nextPlayTime = startTime + audioBuffer.duration;\n      \n      console.log(`播放音频块，时长: ${audioBuffer.duration.toFixed(3)}秒，开始时间: ${startTime.toFixed(3)}秒`);\n    },\n   // 修改 stopAllAudio 方法\nstopAllAudio() {\n  console.log('停止所有音频播放');\n  \n  // 停止所有正在播放的音频\n  this.audioPlayingNodes.forEach(node => {\n    try {\n      node.stop();\n    } catch (e) {\n      console.error('停止音频节点失败:', e);\n    }\n  });\n  this.audioPlayingNodes = [];\n  \n  // 重置状态\n  this.audioQueue = [];\n  this.currentlyPlaying = false;\n  \n  console.log('所有音频已停止，状态已重置');\n}\n  },\n  mounted() {\n    // 监听用户交互，保证 AudioContext 激活\n    window.addEventListener('click', () => {\n      if (!this.userInteracted) {\n        this.resumeAudioContext();\n        this.userInteracted = true;\n      }\n    }, { once: true });\n\n    this.setupTextSocket();\n    this.setupAudioSocket();\n  },\n  beforeDestroy() {\n    if (this.wsText) this.wsText.close();\n    if (this.wsAudio) this.wsAudio.close();\n    this.stopAllAudio();\n    if (this.audioCtx) this.audioCtx.close();\n  }\n};\n</script>\n\n<style scoped>\ninput {\n  margin-right: 8px;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}