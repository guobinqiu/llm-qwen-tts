{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nexport default {\n  data() {\n    return {\n      text: '',\n      message: '',\n      messages: [],\n      sessionID: 'sess1',\n      wsText: null,\n      wsAudio: null,\n      audioCtx: null,\n      audioPlayingNodes: [],\n      userInteracted: false,\n      // 实时音频拼接相关\n      audioChunks: [],\n      // 存储原始Float32Array数据\n      audioSampleRate: 24000,\n      isPlaying: false\n    };\n  },\n  computed: {\n    showMessages() {\n      const all = [...this.messages];\n      if (this.message.trim()) {\n        all.push({\n          role: 'assistant',\n          content: this.message\n        });\n      }\n      return all;\n    }\n  },\n  methods: {\n    sendText() {\n      if (!this.text.trim()) return;\n      if (!this.userInteracted) {\n        this.resumeAudioContext();\n        this.userInteracted = true;\n      }\n      this.wsText.send(this.text.trim());\n      this.messages.push({\n        role: 'user',\n        content: this.text.trim()\n      });\n      this.text = '';\n\n      // 发送新消息时清理之前的音频\n      this.stopAllAudio();\n    },\n    resumeAudioContext() {\n      if (this.audioCtx && this.audioCtx.state === 'suspended') {\n        this.audioCtx.resume();\n      }\n    },\n    setupTextSocket() {\n      this.wsText = new WebSocket(`ws://localhost:8080/ws/text-stream?sessionid=${this.sessionID}`);\n      this.wsText.onopen = () => {\n        console.log('文本 WebSocket 已连接');\n      };\n      this.wsText.onmessage = event => {\n        const chunk = event.data;\n        this.message += chunk;\n        if (chunk === '\\n\\n') {\n          this.messages.push({\n            role: 'assistant',\n            content: this.message\n          });\n          this.message = '';\n        }\n      };\n      this.wsText.onerror = e => {\n        console.error('文本 WebSocket 错误', e);\n      };\n      this.wsText.onclose = () => {\n        console.log('文本 WebSocket 已关闭');\n      };\n    },\n    setupAudioSocket() {\n      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      this.audioChunks = [];\n      this.isPlaying = false;\n      this.wsAudio = new WebSocket(`ws://localhost:8080/ws/audio-stream?sessionid=${this.sessionID}`);\n      this.wsAudio.binaryType = 'arraybuffer';\n      this.wsAudio.onopen = () => {\n        console.log('音频 WebSocket 已连接');\n      };\n      this.wsAudio.onmessage = event => {\n        if (!this.userInteracted) {\n          this.resumeAudioContext();\n          this.userInteracted = true;\n        }\n        try {\n          const arrayBuffer = event.data;\n          const pcmData = new Int16Array(arrayBuffer);\n          console.log('接收到音频数据，字节长度:', arrayBuffer.byteLength, '样本数:', pcmData.length);\n\n          // 转换为Float32数据\n          const float32Data = new Float32Array(pcmData.length);\n          for (let i = 0; i < pcmData.length; i++) {\n            float32Data[i] = pcmData[i] / 32768.0;\n          }\n\n          // 直接添加到块列表\n          this.audioChunks.push(float32Data);\n          console.log(`添加音频块: ${float32Data.length} 样本, 总块数: ${this.audioChunks.length}`);\n\n          // 如果这是第一块或者之前的播放已结束，开始播放\n          if (!this.isPlaying) {\n            this.startContinuousPlayback();\n          }\n        } catch (err) {\n          console.error('处理音频数据失败:', err);\n        }\n      };\n      this.wsAudio.onerror = e => {\n        console.error('音频 WebSocket 错误', e);\n      };\n      this.wsAudio.onclose = () => {\n        console.log('音频 WebSocket 已关闭');\n        this.stopAllAudio();\n      };\n    },\n    // 连续播放方法\n    startContinuousPlayback() {\n      if (this.audioChunks.length === 0 || this.isPlaying) {\n        return;\n      }\n      console.log('开始连续播放音频');\n      this.isPlaying = true;\n\n      // 将所有chunks拼接成一个大的音频buffer\n      const playNextBatch = () => {\n        if (this.audioChunks.length === 0) {\n          console.log('当前批次播放完毕，等待更多数据...');\n          // 等待100ms看是否有新数据\n          setTimeout(() => {\n            if (this.audioChunks.length === 0) {\n              console.log('所有音频块播放完毕');\n              this.isPlaying = false;\n              return;\n            } else {\n              playNextBatch(); // 有新数据，继续播放\n            }\n          }, 100);\n          return;\n        }\n\n        // 一次性处理所有可用的chunks\n        const allChunks = [...this.audioChunks];\n        this.audioChunks = []; // 清空chunks数组\n\n        // 计算总长度\n        let totalLength = 0;\n        allChunks.forEach(chunk => {\n          totalLength += chunk.length;\n        });\n        if (totalLength === 0) {\n          setTimeout(playNextBatch, 50); // 等待更多数据\n          return;\n        }\n\n        // 创建合并的音频数据\n        const mergedData = new Float32Array(totalLength);\n        let offset = 0;\n        allChunks.forEach(chunk => {\n          mergedData.set(chunk, offset);\n          offset += chunk.length;\n        });\n\n        // 创建AudioBuffer\n        const audioBuffer = this.audioCtx.createBuffer(1, mergedData.length, this.audioSampleRate);\n        audioBuffer.getChannelData(0).set(mergedData);\n\n        // 播放\n        const source = this.audioCtx.createBufferSource();\n        source.buffer = audioBuffer;\n        source.connect(this.audioCtx.destination);\n        source.onended = () => {\n          console.log(`播放完成一批音频: ${mergedData.length} 样本, ${audioBuffer.duration.toFixed(3)}秒`);\n          const idx = this.audioPlayingNodes.indexOf(source);\n          if (idx !== -1) {\n            this.audioPlayingNodes.splice(idx, 1);\n          }\n\n          // 继续播放下一批\n          setTimeout(playNextBatch, 10);\n        };\n        this.audioPlayingNodes.push(source);\n        source.start();\n        console.log(`播放音频批次: ${mergedData.length} 样本, ${audioBuffer.duration.toFixed(3)}秒`);\n      };\n      playNextBatch();\n    },\n    stopAllAudio() {\n      console.log('停止所有音频播放');\n      this.audioPlayingNodes.forEach(node => {\n        try {\n          node.stop();\n        } catch (e) {\n          console.error('停止音频节点失败:', e);\n        }\n      });\n      this.audioPlayingNodes = [];\n\n      // 重置状态\n      this.audioChunks = [];\n      this.isPlaying = false;\n      console.log('音频播放已停止，状态已重置');\n    }\n  },\n  mounted() {\n    // 监听用户交互，保证 AudioContext 激活\n    window.addEventListener('click', () => {\n      if (!this.userInteracted) {\n        this.resumeAudioContext();\n        this.userInteracted = true;\n      }\n    }, {\n      once: true\n    });\n    this.setupTextSocket();\n    this.setupAudioSocket();\n  },\n  beforeDestroy() {\n    if (this.wsText) this.wsText.close();\n    if (this.wsAudio) this.wsAudio.close();\n    this.stopAllAudio();\n    if (this.audioCtx) this.audioCtx.close();\n  }\n};","map":{"version":3,"names":["data","text","message","messages","sessionID","wsText","wsAudio","audioCtx","audioPlayingNodes","userInteracted","audioChunks","audioSampleRate","isPlaying","computed","showMessages","all","trim","push","role","content","methods","sendText","resumeAudioContext","send","stopAllAudio","state","resume","setupTextSocket","WebSocket","onopen","console","log","onmessage","event","chunk","onerror","e","error","onclose","setupAudioSocket","window","AudioContext","webkitAudioContext","binaryType","arrayBuffer","pcmData","Int16Array","byteLength","length","float32Data","Float32Array","i","startContinuousPlayback","err","playNextBatch","setTimeout","allChunks","totalLength","forEach","mergedData","offset","set","audioBuffer","createBuffer","getChannelData","source","createBufferSource","buffer","connect","destination","onended","duration","toFixed","idx","indexOf","splice","start","node","stop","mounted","addEventListener","once","beforeDestroy","close"],"sources":["src/components/ChatPage.vue"],"sourcesContent":["<template>\n  <div>\n    <div>\n      <input\n        v-model=\"text\"\n        placeholder=\"输入文本，回车发送\"\n        @keyup.enter=\"sendText\"\n        style=\"width: 300px; padding: 8px\"\n      />\n      <button @click=\"sendText\">发送</button>\n      <button @click=\"stopAllAudio\" style=\"margin-left: 10px; background-color: #ff4444; color: white;\">停止音频</button>\n    </div>\n\n    <div style=\"margin-top: 20px;\">\n      <div v-for=\"(msg, index) in showMessages\" :key=\"index\">\n        <b>{{ msg.role }}:</b> {{ msg.content }}\n      </div>\n    </div>\n\n    <div style=\"margin-top: 10px; color: #666; font-size: 12px;\">\n      音频状态: {{ isPlaying ? '播放中' : '空闲' }} | \n      待播放块数: {{ audioChunks.length }} |\n      正在播放节点: {{ audioPlayingNodes.length }}\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      text: '',\n      message: '',\n      messages: [],\n      sessionID: 'sess1',\n      wsText: null,\n      wsAudio: null,\n      audioCtx: null,\n      audioPlayingNodes: [],\n      userInteracted: false,\n      \n      // 实时音频拼接相关\n      audioChunks: [], // 存储原始Float32Array数据\n      audioSampleRate: 24000,\n      isPlaying: false,\n    };\n  },\n  computed: {\n    showMessages() {\n      const all = [...this.messages];\n      if (this.message.trim()) {\n        all.push({ role: 'assistant', content: this.message });\n      }\n      return all;\n    }\n  },\n  methods: {\n    sendText() {\n      if (!this.text.trim()) return;\n\n      if (!this.userInteracted) {\n        this.resumeAudioContext();\n        this.userInteracted = true;\n      }\n\n      this.wsText.send(this.text.trim());\n      this.messages.push({ role: 'user', content: this.text.trim() });\n      this.text = '';\n      \n      // 发送新消息时清理之前的音频\n      this.stopAllAudio();\n    },\n    \n    resumeAudioContext() {\n      if (this.audioCtx && this.audioCtx.state === 'suspended') {\n        this.audioCtx.resume();\n      }\n    },\n    \n    setupTextSocket() {\n      this.wsText = new WebSocket(`ws://localhost:8080/ws/text-stream?sessionid=${this.sessionID}`);\n\n      this.wsText.onopen = () => {\n        console.log('文本 WebSocket 已连接');\n      };\n\n      this.wsText.onmessage = (event) => {\n        const chunk = event.data;\n        this.message += chunk;\n\n        if (chunk === '\\n\\n') {\n          this.messages.push({ role: 'assistant', content: this.message });\n          this.message = '';\n        }\n      };\n\n      this.wsText.onerror = (e) => {\n        console.error('文本 WebSocket 错误', e);\n      };\n\n      this.wsText.onclose = () => {\n        console.log('文本 WebSocket 已关闭');\n      };\n    },\n    \n    setupAudioSocket() {\n      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      this.audioChunks = [];\n      this.isPlaying = false;\n\n      this.wsAudio = new WebSocket(`ws://localhost:8080/ws/audio-stream?sessionid=${this.sessionID}`);\n      this.wsAudio.binaryType = 'arraybuffer';\n\n      this.wsAudio.onopen = () => {\n        console.log('音频 WebSocket 已连接');\n      };\n\n      this.wsAudio.onmessage = (event) => {\n        if (!this.userInteracted) {\n          this.resumeAudioContext();\n          this.userInteracted = true;\n        }\n\n        try {\n          const arrayBuffer = event.data;\n          const pcmData = new Int16Array(arrayBuffer);\n          \n          console.log('接收到音频数据，字节长度:', arrayBuffer.byteLength, '样本数:', pcmData.length);\n          \n          // 转换为Float32数据\n          const float32Data = new Float32Array(pcmData.length);\n          for (let i = 0; i < pcmData.length; i++) {\n            float32Data[i] = pcmData[i] / 32768.0;\n          }\n          \n          // 直接添加到块列表\n          this.audioChunks.push(float32Data);\n          console.log(`添加音频块: ${float32Data.length} 样本, 总块数: ${this.audioChunks.length}`);\n          \n          // 如果这是第一块或者之前的播放已结束，开始播放\n          if (!this.isPlaying) {\n            this.startContinuousPlayback();\n          }\n          \n        } catch (err) {\n          console.error('处理音频数据失败:', err);\n        }\n      };\n\n      this.wsAudio.onerror = (e) => {\n        console.error('音频 WebSocket 错误', e);\n      };\n\n      this.wsAudio.onclose = () => {\n        console.log('音频 WebSocket 已关闭');\n        this.stopAllAudio();\n      };\n    },\n    \n    // 连续播放方法\n    startContinuousPlayback() {\n      if (this.audioChunks.length === 0 || this.isPlaying) {\n        return;\n      }\n      \n      console.log('开始连续播放音频');\n      this.isPlaying = true;\n      \n      // 将所有chunks拼接成一个大的音频buffer\n      const playNextBatch = () => {\n        if (this.audioChunks.length === 0) {\n          console.log('当前批次播放完毕，等待更多数据...');\n          // 等待100ms看是否有新数据\n          setTimeout(() => {\n            if (this.audioChunks.length === 0) {\n              console.log('所有音频块播放完毕');\n              this.isPlaying = false;\n              return;\n            } else {\n              playNextBatch(); // 有新数据，继续播放\n            }\n          }, 100);\n          return;\n        }\n        \n        // 一次性处理所有可用的chunks\n        const allChunks = [...this.audioChunks];\n        this.audioChunks = []; // 清空chunks数组\n        \n        // 计算总长度\n        let totalLength = 0;\n        allChunks.forEach(chunk => {\n          totalLength += chunk.length;\n        });\n        \n        if (totalLength === 0) {\n          setTimeout(playNextBatch, 50); // 等待更多数据\n          return;\n        }\n        \n        // 创建合并的音频数据\n        const mergedData = new Float32Array(totalLength);\n        let offset = 0;\n        allChunks.forEach(chunk => {\n          mergedData.set(chunk, offset);\n          offset += chunk.length;\n        });\n        \n        // 创建AudioBuffer\n        const audioBuffer = this.audioCtx.createBuffer(1, mergedData.length, this.audioSampleRate);\n        audioBuffer.getChannelData(0).set(mergedData);\n        \n        // 播放\n        const source = this.audioCtx.createBufferSource();\n        source.buffer = audioBuffer;\n        source.connect(this.audioCtx.destination);\n        \n        source.onended = () => {\n          console.log(`播放完成一批音频: ${mergedData.length} 样本, ${audioBuffer.duration.toFixed(3)}秒`);\n          const idx = this.audioPlayingNodes.indexOf(source);\n          if (idx !== -1) {\n            this.audioPlayingNodes.splice(idx, 1);\n          }\n          \n          // 继续播放下一批\n          setTimeout(playNextBatch, 10);\n        };\n        \n        this.audioPlayingNodes.push(source);\n        source.start();\n        \n        console.log(`播放音频批次: ${mergedData.length} 样本, ${audioBuffer.duration.toFixed(3)}秒`);\n      };\n      \n      playNextBatch();\n    },\n    \n    stopAllAudio() {\n      console.log('停止所有音频播放');\n      \n      this.audioPlayingNodes.forEach(node => {\n        try {\n          node.stop();\n        } catch (e) {\n          console.error('停止音频节点失败:', e);\n        }\n      });\n      this.audioPlayingNodes = [];\n      \n      // 重置状态\n      this.audioChunks = [];\n      this.isPlaying = false;\n      \n      console.log('音频播放已停止，状态已重置');\n    }\n  },\n  \n  mounted() {\n    // 监听用户交互，保证 AudioContext 激活\n    window.addEventListener('click', () => {\n      if (!this.userInteracted) {\n        this.resumeAudioContext();\n        this.userInteracted = true;\n      }\n    }, { once: true });\n\n    this.setupTextSocket();\n    this.setupAudioSocket();\n  },\n  \n  beforeDestroy() {\n    if (this.wsText) this.wsText.close();\n    if (this.wsAudio) this.wsAudio.close();\n    this.stopAllAudio();\n    if (this.audioCtx) this.audioCtx.close();\n  }\n};\n</script>\n\n<style scoped>\ninput {\n  margin-right: 8px;\n}\n\nbutton {\n  padding: 8px 16px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n  background-color: #007bff;\n  color: white;\n}\n\nbutton:hover {\n  background-color: #0056b3;\n}\n</style>"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}