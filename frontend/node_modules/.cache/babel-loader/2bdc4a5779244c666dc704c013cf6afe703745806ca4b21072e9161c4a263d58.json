{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nexport default {\n  data() {\n    return {\n      textMessage: '',\n      messages: [],\n      sessionID: 'sess1',\n      // 你实际的 sessionid\n      wsText: null,\n      wsAudio: null,\n      audioCtx: null,\n      audioPlayingNodes: [] // 当前播放的 AudioBufferSourceNode 列表\n    };\n  },\n  methods: {\n    sendText() {\n      if (!this.textMessage.trim()) return;\n      if (this.wsText && this.wsText.readyState === WebSocket.OPEN) {\n        this.wsText.send(this.textMessage.trim());\n\n        // 显示用户消息\n        this.messages.push({\n          role: 'user',\n          content: this.textMessage.trim()\n        });\n        this.textMessage = '';\n      }\n    },\n    setupTextSocket() {\n      this.wsText = new WebSocket(`ws://localhost:8080/ws/text-stream?sessionid=${this.sessionID}`);\n      this.wsText.onopen = () => {\n        console.log('文本 WebSocket 已连接');\n      };\n      let partialMsg = '';\n      this.wsText.onmessage = event => {\n        const chunk = event.data;\n        partialMsg += chunk;\n\n        // 假设后端用 \"\\n\\n\" 来表示消息结束\n        if (partialMsg.endsWith('\\n\\n')) {\n          // 去掉末尾换行\n          const msg = partialMsg.trim();\n          this.messages.push({\n            role: 'assistant',\n            content: msg\n          });\n          partialMsg = '';\n        }\n      };\n      this.wsText.onerror = e => {\n        console.error('文本 WebSocket 错误', e);\n      };\n      this.wsText.onclose = () => {\n        console.log('文本 WebSocket 已关闭');\n      };\n    },\n    setupAudioSocket() {\n      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n      this.wsAudio = new WebSocket(`ws://localhost:8080/ws/audio-stream?sessionid=${this.sessionID}`);\n      this.wsAudio.binaryType = 'arraybuffer';\n      this.wsAudio.onopen = () => {\n        console.log('音频 WebSocket 已连接');\n      };\n      this.wsAudio.onmessage = async event => {\n        try {\n          const arrayBuffer = event.data;\n          // PCM 16bit little endian, 16kHz, mono\n\n          // 转为 Int16Array\n          const pcmData = new Int16Array(arrayBuffer);\n          // 转换为 Float32Array [-1,1]\n          const float32Data = new Float32Array(pcmData.length);\n          for (let i = 0; i < pcmData.length; i++) {\n            float32Data[i] = pcmData[i] / 32768;\n          }\n\n          // 创建 AudioBuffer\n          const audioBuffer = this.audioCtx.createBuffer(1, float32Data.length, 16000);\n          audioBuffer.getChannelData(0).set(float32Data);\n\n          // 创建播放节点\n          const source = this.audioCtx.createBufferSource();\n          source.buffer = audioBuffer;\n          source.connect(this.audioCtx.destination);\n\n          // 播放完从列表移除，防止内存泄漏\n          source.onended = () => {\n            const idx = this.audioPlayingNodes.indexOf(source);\n            if (idx !== -1) this.audioPlayingNodes.splice(idx, 1);\n          };\n          this.audioPlayingNodes.push(source);\n          source.start();\n        } catch (err) {\n          console.error('播放PCM数据失败:', err);\n        }\n      };\n      this.wsAudio.onerror = e => {\n        console.error('音频 WebSocket 错误', e);\n      };\n      this.wsAudio.onclose = () => {\n        console.log('音频 WebSocket 已关闭');\n        this.stopAllAudio();\n      };\n    },\n    stopAllAudio() {\n      // 停止所有正在播放的音频节点\n      this.audioPlayingNodes.forEach(node => {\n        try {\n          node.stop();\n        } catch {}\n      });\n      this.audioPlayingNodes = [];\n    }\n  },\n  mounted() {\n    this.setupTextSocket();\n    this.setupAudioSocket();\n  },\n  beforeDestroy() {\n    if (this.wsText) this.wsText.close();\n    if (this.wsAudio) this.wsAudio.close();\n    this.stopAllAudio();\n    if (this.audioCtx) this.audioCtx.close();\n  }\n};","map":{"version":3,"names":["data","textMessage","messages","sessionID","wsText","wsAudio","audioCtx","audioPlayingNodes","methods","sendText","trim","readyState","WebSocket","OPEN","send","push","role","content","setupTextSocket","onopen","console","log","partialMsg","onmessage","event","chunk","endsWith","msg","onerror","e","error","onclose","setupAudioSocket","window","AudioContext","webkitAudioContext","binaryType","arrayBuffer","pcmData","Int16Array","float32Data","Float32Array","length","i","audioBuffer","createBuffer","getChannelData","set","source","createBufferSource","buffer","connect","destination","onended","idx","indexOf","splice","start","err","stopAllAudio","forEach","node","stop","mounted","beforeDestroy","close"],"sources":["src/components/ChatPage.vue"],"sourcesContent":["<template>\n  <div>\n    <h2>Chat with TTS</h2>\n    <div>\n      <input\n        v-model=\"textMessage\"\n        placeholder=\"输入文本，回车发送\"\n        @keyup.enter=\"sendText\"\n        style=\"width: 300px; padding: 8px\"\n      />\n      <button @click=\"sendText\">发送</button>\n    </div>\n\n    <div style=\"margin-top: 20px;\">\n      <h3>文本回答：</h3>\n      <div v-for=\"(msg, index) in messages\" :key=\"index\" style=\"margin-bottom: 8px;\">\n        <b>{{ msg.role }}:</b> {{ msg.content }}\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      textMessage: '',\n      messages: [],\n\n      sessionID: 'sess1', // 你实际的 sessionid\n      wsText: null,\n      wsAudio: null,\n      audioCtx: null,\n      audioPlayingNodes: [], // 当前播放的 AudioBufferSourceNode 列表\n    };\n  },\n  methods: {\n    sendText() {\n      if (!this.textMessage.trim()) return;\n\n      if (this.wsText && this.wsText.readyState === WebSocket.OPEN) {\n        this.wsText.send(this.textMessage.trim());\n\n        // 显示用户消息\n        this.messages.push({ role: 'user', content: this.textMessage.trim() });\n        this.textMessage = '';\n      }\n    },\n    setupTextSocket() {\n      this.wsText = new WebSocket(`ws://localhost:8080/ws/text-stream?sessionid=${this.sessionID}`);\n\n      this.wsText.onopen = () => {\n        console.log('文本 WebSocket 已连接');\n      };\n\n      let partialMsg = '';\n      this.wsText.onmessage = (event) => {\n        const chunk = event.data;\n        partialMsg += chunk;\n\n        // 假设后端用 \"\\n\\n\" 来表示消息结束\n        if (partialMsg.endsWith('\\n\\n')) {\n          // 去掉末尾换行\n          const msg = partialMsg.trim();\n          this.messages.push({ role: 'assistant', content: msg });\n          partialMsg = '';\n        }\n      };\n\n      this.wsText.onerror = (e) => {\n        console.error('文本 WebSocket 错误', e);\n      };\n\n      this.wsText.onclose = () => {\n        console.log('文本 WebSocket 已关闭');\n      };\n    },\n    setupAudioSocket() {\n      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n\n      this.wsAudio = new WebSocket(`ws://localhost:8080/ws/audio-stream?sessionid=${this.sessionID}`);\n      this.wsAudio.binaryType = 'arraybuffer';\n\n      this.wsAudio.onopen = () => {\n        console.log('音频 WebSocket 已连接');\n      };\n\n      this.wsAudio.onmessage = async (event) => {\n        try {\n          const arrayBuffer = event.data;\n          // PCM 16bit little endian, 16kHz, mono\n\n          // 转为 Int16Array\n          const pcmData = new Int16Array(arrayBuffer);\n          // 转换为 Float32Array [-1,1]\n          const float32Data = new Float32Array(pcmData.length);\n          for (let i = 0; i < pcmData.length; i++) {\n            float32Data[i] = pcmData[i] / 32768;\n          }\n\n          // 创建 AudioBuffer\n          const audioBuffer = this.audioCtx.createBuffer(1, float32Data.length, 16000);\n          audioBuffer.getChannelData(0).set(float32Data);\n\n          // 创建播放节点\n          const source = this.audioCtx.createBufferSource();\n          source.buffer = audioBuffer;\n          source.connect(this.audioCtx.destination);\n\n          // 播放完从列表移除，防止内存泄漏\n          source.onended = () => {\n            const idx = this.audioPlayingNodes.indexOf(source);\n            if (idx !== -1) this.audioPlayingNodes.splice(idx, 1);\n          };\n\n          this.audioPlayingNodes.push(source);\n          source.start();\n\n        } catch (err) {\n          console.error('播放PCM数据失败:', err);\n        }\n      };\n\n      this.wsAudio.onerror = (e) => {\n        console.error('音频 WebSocket 错误', e);\n      };\n\n      this.wsAudio.onclose = () => {\n        console.log('音频 WebSocket 已关闭');\n        this.stopAllAudio();\n      };\n    },\n    stopAllAudio() {\n      // 停止所有正在播放的音频节点\n      this.audioPlayingNodes.forEach(node => {\n        try {\n          node.stop();\n        } catch {}\n      });\n      this.audioPlayingNodes = [];\n    }\n  },\n  mounted() {\n    this.setupTextSocket();\n    this.setupAudioSocket();\n  },\n  beforeDestroy() {\n    if (this.wsText) this.wsText.close();\n    if (this.wsAudio) this.wsAudio.close();\n    this.stopAllAudio();\n    if (this.audioCtx) this.audioCtx.close();\n  }\n};\n</script>\n\n<style scoped>\ninput {\n  margin-right: 8px;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}